<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>DOOPT LO map</title>
	<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
	<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
	<link rel="stylesheet" href="{{ url_for('static', filename='modal_windows.css') }}">
</head>

<body>
	<div class="button-container">
		<!-- Filter Button -->
		<div class="show-container">
			<label>
				<input type="checkbox" id="equipmentShow" checked>
				Оборудование на тропе
			</label>
			<label>
				<input type="checkbox" id="objectsShow" checked>
				Объекты ООПТ
			</label>
		</div>
		<div class="filter-container">
			<button id="filterButton">Filter</button>
			<!-- Filter Options Box (initially hidden) -->
			<div id="filterOptions" style="display: none;">
				<!-- Navigation Tabs -->
				<div style="text-align: center; margin-bottom: 10px;">
					<span id="routesTab" class="filter-tab active-tab">Routes</span> |
					<span id="regionsTab" class="filter-tab">Regions</span>
				</div>
				<!-- Routes Filter (Page 1) -->
				<div id="routesFilter" class="filter-page">
					<div class="filter-column">
						<label><strong>Тип:</strong></label>
						<div class="checkbox-option">
							<input type="checkbox" id="movementRetA" value="Пешеходная">
							<label for="movementRetA">Пешеходная</label>
						</div>
						<div class="checkbox-option">
							<input type="checkbox" id="movementRetB" value="Велосипедная">
							<label for="movementRetB">Велосипедная</label>
						</div>
						<div class="checkbox-option">
							<input type="checkbox" id="movementRetC" value="Лыжная">
							<label for="movementRetC">Лыжная</label>
						</div>
						<div class="checkbox-option">
							<input type="checkbox" id="movementRetD" value="Комбинированная">
							<label for="movementRetD">Комбинированная</label>
						</div>
					</div>
					<div class="filter-column">
						<label><strong>Протяженность:</strong></label>
						<div class="checkbox-option">
							<input type="checkbox" id="length1" value="1-2">
							<label for="length1">1-2 км</label>
						</div>
						<div class="checkbox-option">
							<input type="checkbox" id="length2" value="2-5">
							<label for="length2">2-5 км</label>
						</div>
						<div class="checkbox-option">
							<input type="checkbox" id="length3" value="5-10">
							<label for="length3">5-10 км</label>
						</div>
						<div class="checkbox-option">
							<input type="checkbox" id="length4" value="10+">
							<label for="length4">10+ км</label>
						</div>
					</div>
				</div>
				<!-- Regions Filter (Page 2) -->
				<div id="regionsFilter" class="filter-page" style="display: none;">
					<div class="filter-column">
						<label><strong>Категория:</strong></label>
						<div class="checkbox-option">
							<input type="checkbox" id="category1" value="памятник природы">
							<label for="category1">Памятник природы</label>
						</div>
						<div class="checkbox-option">
							<input type="checkbox" id="category2" value="государственный природный заказник">
							<label for="category2">Природный заказник</label>
						</div>
						<div class="checkbox-option">
							<input type="checkbox" id="category3" value="природный парк">
							<label for="category3">Природный парк</label>
						</div>
					</div>
				</div>
				<!-- Apply and Reset Buttons -->
				<div style="display: flex; justify-content: space-between; margin-top: 10px;">
					<button id="applyFilter">Apply</button>
					<button id="resetFilter">Reset</button>
				</div>
			</div>
		</div>
		<button id="load-routes">Load Routes</button>
		<button id="load-regions">Load Regions</button>
	</div>
	<div id="infoModal" class="modal" role="dialog" aria-labelledby="modalTitle" aria-hidden="true">
		<div class="modal-content">
			<div class="modal-header" id="modalHeader">
				<span class="close" role="button" aria-label="Close">&times;</span>
				<h2 id="modalTitle">Modal Title</h2>
			</div>
			<div id="modalText">
				<p class="indented">Information will appear here</p>
				<div class="show-more-section">
					<p>This is the initial text that is always shown.</p>
					<div id="moreContent" class="hidden">
						<p class="secret">This is additional content that is shown when "Show More" is clicked.</p>
					</div>
					<a href="#" id="showMoreButton">Show More</a>
				</div>
			</div>
		</div>
	</div>
	<div id="map"></div>
	<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
	<script>
		// Bounds for the map using coordinates
		var southWest = L.latLng(58.28, 27.68); // Bottom left corner
		var northEast = L.latLng(61.92, 36.61);  // Top right corner
		var bounds = L.latLngBounds(southWest, northEast);

		// Initialize the map and fit it to the bounds
		var map = L.map('map').fitBounds(bounds); // Automatically sets the view to fit the bounds

		// OpenStreetMap tiles
		L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
			maxZoom: 19,
			attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
		}).addTo(map);
		// Restrict panning to the bounds
		map.setMaxBounds(bounds);
		var minZoomLevel = 7;
		map.setMinZoom(minZoomLevel);
		// Layer references
		let routesLayer = null;
		let regionsLayer = null;
		let equipmentLayer  = null;
		let objectsLayer = null;
		let routesData = null;
		let regionsData = null;
		let equipmentData;
		let objectsData = null;
		const apiUrl = "{{ url_for('get_data') }}";
		// Functions to fetch data from Flask API
		function fetchData() {
			fetch(`${apiUrl}?type=routes`) 
				.then(response => response.json())
				.then(data => {
					routesData = data; 
				})
				.catch(error => console.error('Error fetching routes:', error));
		}
		fetchData();

		function fetchRegions() {
			fetch(`${apiUrl}?type=regions`)
				.then(response => response.json())
				.then(data => {
					regionsData = data;
				})
				.catch(error => console.error('Error fetching regions:', error));
		}
		fetchRegions();

		function fetchEquip() {
			fetch(`${apiUrl}?type=equipment`)
				.then(response => response.json())
				.then(data => {
					equipmentData = data;
				})
				.catch(error => console.error('Error fetching equip:', error));
		}
		fetchEquip();

		function fetchObjects() {
			fetch(`${apiUrl}?type=objects`)
				.then(response => response.json())
				.then(data => {
					objectsData = data;
				})
				.catch(error => console.error('Error fetching obj:', error));
		}
		fetchObjects();

		function generateModalContent(data, targetName) {
			const targetItem = data.find(item => item.name === targetName);
			if (!targetItem) {
				return `<p>No information available for the selected item.</p>`;
			}
			console.log()
			// let content = '';
			let content = `
				<strong>Наименование:</strong> ${targetItem.name || 'N/A'}<br>
				<strong>Протяженность тропы:</strong> ${targetItem.length || 'N/A'} км <br>
				<strong>Тип тропы по типу передвижения:</strong> ${targetItem.movement_ret || 'N/A'} <br>
				<strong>Время прохождения тропы:</strong> ${ 
				targetItem.time_min === null ? 'N/A' : (targetItem.time_min.split('T'))[1] } - 
				${
				targetItem.max_time === null ? 'N/A' : (targetItem.max_time.split('T'))[1] } ч <br>
				<strong>Регион:</strong> ${targetItem.region || 'N/A'} <br>				
				<br>`;

			// content += '</ul>';
			return content;
		}
		function generateModalContent2(data, properties) {
				// const targetItem = data.find(item => item.name === targetName);
				// if (!targetItem) {
				// 	return `<p>No information available for the selected item.</p>`;
				// }
				console.log()
				// let content = '';
				let content = `
				<strong>Наименование:</strong> ${properties.name || 'N/A'}<br>
				<strong>Категория:</strong> ${properties.category || 'N/A'} <br>`;

				// content += '</ul>';
				return content;
			}
	
		function generateAdditionalModalContent(data, targetName) {
			const targetItem = data.find(item => item.name === targetName);
			if (!targetItem) {
				return `<p>No information available for the selected item.</p>`;
			}
			// let content = '<ul>';
			let content = `
				<strong>Эксплуатирует и управляет:</strong> ${targetItem.controls_ret || 'N/A'}<br>
				<strong>Статус:</strong> ${targetItem.status_ret || 'N/A'}<br>
				<strong>Доступна для людей с ограниченными возможностями:</strong> ${
				targetItem.disabled_person === true ? (targetItem.disabled_explanation || 'N/A')
					: 'Нет'}<br>
				<strong>Проходит приграничная зона или территория с особым режимом пребывания:</strong> ${
				targetItem.stay_mode === true ? 'Да' : targetItem.stay_mode === false ? 'Нет' : 'N/A'}

			<br>`;
			// content += '</ul>';
			return content;
		}

		function onEachFeature(feature, layer, layerType) {
			if (feature.properties && feature.properties.name) {
				// Bind a popup to the layer, showing a clickable link
				layer.bindPopup(`<a href="#" class="popup-link">${feature.properties.name}</a>`);

				layer.on('popupopen', function () {
					const link = document.querySelector('.popup-link');
					if (link) {
						link.addEventListener('click', function (e) {
							e.preventDefault();
							if (layerType === 'routes' && routesData) {
								//openModal('Routes Information', generateModalContent(routesData));
								openModal('Routes Information', generateModalContent(routesData, feature.properties.name), generateAdditionalModalContent(routesData, feature.properties.name));
							} else if (layerType === 'regions' && regionsData) {
								//openModal('Regions Information', generateModalContent(regionsData));
								openModal('Regions Information', generateModalContent2(regionsData, feature.properties));
							} 
							//else {
							// 	openModal('Data Not Available', 'No data could be found for the selected type.');
							// }
						});
					}
				});
			}
		}
	
		function openModal(title, infoText, moreInfo) {
			// Update the modal title
			const modalTitle = document.getElementById('modalTitle');
			modalTitle.textContent = title;
			// Update the modal info text
			const modalText = document.getElementById('modalText');
			modalText.querySelector('p.indented').innerHTML = infoText;
			// Update the "Show More" section
			const moreContent = document.getElementById('moreContent');
			moreContent.innerHTML = moreInfo;
			moreContent.classList.add('hidden'); // Hide the additional content initially
			document.getElementById('showMoreButton').textContent = 'Show More';
			const modal = document.getElementById('infoModal');
			modal.style.display = 'block';
		}

		// Function to close the modal
		function closeModal() {
			const modal = document.getElementById('infoModal');
			modal.style.display = 'none';
		}
		// Close the modal when the close button is clicked
		document.querySelector('.close').addEventListener('click', function () {
			const modal = document.getElementById('infoModal');
			modal.style.display = 'none';
		})
		// Close the modal when clicking outside of it
		window.addEventListener('click', function (event) {
			const modal = document.getElementById('infoModal');
			if (event.target === modal) {
				modal.style.display = 'none';
			}
		});

		let geojsonData = {};

		function fetchGeoJSON(url) {
			return fetch(url)
				.then(response => {
					if (!response.ok) {
						throw new Error('Something went wrong');
					}
					return response.json();
				})
				.catch(error => {
					console.error('There was a problem with the fetch operation:', error);
					throw error; // Re-throw to handle in the calling function
				});
		}

		// Function to process the GeoJSON data
		function processGeoJSON(data, layerType, filtered) {
			console.log("data", data);
			// Create the GeoJSON layer with custom style and event handlers
			const geoJsonLayer = L.geoJSON(data, {
				style: function (feature) {
					return {
						color: 'black',
						weight: 2
					};
				},
				onEachFeature: function (feature, layer) {
					// console.log("feature", feature);
					// console.log("layer", layer);
					onEachFeature(feature, layer, layerType);
				}
			});
			//geoJsonLayer.addTo(map);
			// Add or update the layer based on the layer type
			if (layerType === 'routes') {
				if (routesLayer) {
					map.removeLayer(routesLayer);
					if (!filtered) { routesLayer = null; }
				}
				else {
					if (!filtered) {
						routesLayer = geoJsonLayer;
						routesLayer.addTo(map);
					}
				}
				if (filtered) {
					routesLayer = geoJsonLayer;
					routesLayer.addTo(map); 
				}
			} 
			else if (layerType === 'equipment') {
				if (!filtered) {
					if (equipmentLayer) {
						console.log("1");
						map.removeLayer(equipmentLayer);
						equipmentLayer = null; 
					}
					else {
						console.log("2");
						equipmentLayer = geoJsonLayer;
						equipmentLayer.addTo(map);
					}
				}
				if (filtered && equipmentLayer != null)  {
					console.log("3");
					//works
					map.removeLayer(equipmentLayer);
					equipmentLayer = geoJsonLayer;
					equipmentLayer.addTo(map);
				}
			} 
			else if (layerType === 'regions') {
				// if (regionsLayer) {
				// 	console.log("remove", regionsLayer)
				// 	map.removeLayer(regionsLayer);
				// 	regionsLayer = null;
				// }
				// else {
				// 	regionsLayer = geoJsonLayer;
				// 	console.log("add", regionsLayer)
				// 	regionsLayer.addTo(map);
				// }
				if (regionsLayer) {
					map.removeLayer(regionsLayer);
					if (!filtered) { regionsLayer = null; }
				}
				else {
					if (!filtered) {
						regionsLayer = geoJsonLayer;
						regionsLayer.addTo(map);
					}
				}
				if (filtered) {
					regionsLayer = geoJsonLayer;
					regionsLayer.addTo(map);
				}
			} 
			else if (layerType === 'objects') {
				console.log("geoJsonLayer", geoJsonLayer)
				if (objectsLayer) {
					console.log("remove", objectsLayer)
					map.removeLayer(objectsLayer);
					objectsLayer = null;
				}
				else {
					console.log("objectsLayer", objectsLayer)
					objectsLayer = geoJsonLayer;
					console.log("objectsLayer2", objectsLayer)

					// console.log("add", objectsLayer)
					objectsLayer.addTo(map);
				}
			}
		}

		// Unified function to fetch and process GeoJSON data
		function loadGeoJSON(url, layerType) {
			fetchGeoJSON(url)
				.then(data => {
					geojsonData[layerType] = data;
					console.log("geojsonData[layerType]", data)
					processGeoJSON(data, layerType, false);
				})
				.catch(error => {
					console.error('Failed to load and process GeoJSON data:', error);
				});
		}
		
		// Get references to tabs and filter pages
		const routesTab = document.getElementById("routesTab");
		const regionsTab = document.getElementById("regionsTab");
		const routesFilter = document.getElementById("routesFilter");
		const regionsFilter = document.getElementById("regionsFilter");

		// Function to activate the Routes filter
		routesTab.addEventListener("click", function () {
			routesFilter.style.display = "block";
			regionsFilter.style.display = "none";
			routesTab.classList.add("active-tab");
			regionsTab.classList.remove("active-tab");
		});

		// Function to activate the Regions filter
		regionsTab.addEventListener("click", function () {
			regionsFilter.style.display = "block";
			routesFilter.style.display = "none";
			regionsTab.classList.add("active-tab");
			routesTab.classList.remove("active-tab");
		});


		function filterData(selectedMovementRet, selectedLength) {
			const layerType = 'routes';
			if (!geojsonData['routes'] || !routesData) return; 
			const lengthRanges = selectedLength.map(range => {
				const [min, max] = range.includes('+') ? [10, Infinity] : range.split('-').map(Number);
				return { min, max };
			});
			const matchingIds = new Set(
				routesData
					.filter(item => {
						const matchesMovementRet = selectedMovementRet.length === 0 ||
							selectedMovementRet.includes(item.movement_ret);
						const matchesLength = lengthRanges.length === 0 || lengthRanges.some(({ min, max }) =>
							item.length >= min && item.length <= max
						);
						matchesLength ? console.log("length:", item.length) : console.log("N/A:");
						return matchesMovementRet && matchesLength;
					})
					.map(item => item.id)
			);
			console.log("matchingIds:", matchingIds);
			// Filter GeoJSON features based on these IDs
			const filteredFeatures = geojsonData['routes'].features.filter(feature =>
				matchingIds.has(feature.properties.id) // assuming properties.id is used in GeoJSON for db id
			);
			const filteredGeoData = { ...geojsonData['routes'], features: filteredFeatures };
			processGeoJSON(filteredGeoData, layerType, true);

			if (!geojsonData['equipment']) return;
			console.log("ff", geojsonData['equipment']);
			const matchingEquipmentIds = new Set(
				geojsonData['equipment'].features
					.filter(feature => {
						const item = feature.properties;
						const matchesRoute = matchingIds.has(item.link_to_route);
						// console.log("matchesRoute:", matchesRoute);
						return matchesRoute;
					})
					.map(feature => feature.properties.id)
			);
			console.log("matchingEquipmentIds:", matchingEquipmentIds);
			const filteredEquipmentFeatures = geojsonData['equipment'].features.filter(feature =>
				matchingEquipmentIds.has(feature.properties.id)
			);

			// Update GeoJSON data with only the filtered features
			const filteredEquipment = { ...geojsonData['routes'], features: filteredEquipmentFeatures };
			processGeoJSON(filteredEquipment, 'equipment', true);
		}

		function filterRegions(selectedCategory) {
			if (!geojsonData['regions'] || !regionsData) return; 
			const matchingIds = new Set(
				geojsonData['regions'].features
					.filter(feature => {
						const item = feature.properties;
						// console.log("item", item);
						// console.log("item.category", item.category);
						// console.log("selectedCategory", selectedCategory);
						const matchesCategory = selectedCategory.includes(item.category);
						console.log("matchesCategory", matchesCategory);
						return matchesCategory;
					})
					.map(feature => feature.properties.id)
			);
			const filteredRegionsFeatures = geojsonData['regions'].features.filter(feature =>
				matchingIds.has(feature.properties.id)
			);
			const filteredRegions = { ...geojsonData['regions'], features: filteredRegionsFeatures };
			processGeoJSON(filteredRegions, 'regions', true);
		}
		// Toggle the filter options display on button click
		document.getElementById('filterButton').addEventListener('click', () => {
			const filterOptions = document.getElementById('filterOptions');
			filterOptions.style.display = filterOptions.style.display === 'none' ? 'block' : 'none';
		});

		// Apply the filter based on selected checkboxes
		function filterRoutesAndEquipment() {
			const selectedMovementRet = Array.from(document.querySelectorAll('#routesFilter input[type="checkbox"]:checked'))
				.filter(checkbox => checkbox.id.startsWith('movementRet'))
				.map(checkbox => checkbox.value);
			const selectedLength = Array.from(document.querySelectorAll('#routesFilter input[type="checkbox"]:checked'))
				.filter(checkbox => checkbox.id.startsWith('length'))
				.map(checkbox => checkbox.value);
			filterData(selectedMovementRet, selectedLength)
		};

		document.getElementById('applyFilter').addEventListener('click', () => {
			if (routesTab.classList.contains("active-tab")) filterRoutesAndEquipment();
			else if (regionsTab.classList.contains("active-tab")) {
				const selectedCategory = Array.from(document.querySelectorAll('#regionsFilter input[type="checkbox"]:checked'))
					.filter(checkbox => checkbox.id.startsWith('category'))
					.map(checkbox => checkbox.value);
				filterRegions(selectedCategory)
			}
		});
		document.getElementById('resetFilter').addEventListener('click', () => {
			if (routesTab.classList.contains("active-tab")) 
			{
				const checkboxes = document.querySelectorAll('#routesFilter input[type="checkbox"]')
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			//reset()
				processGeoJSON(geojsonData['routes'], 'routes', true)
				if (equipmentLayer != null) processGeoJSON(geojsonData['equipment'], 'equipment', true)
			}
			else if (regionsTab.classList.contains("active-tab")) {
				const checkboxes = document.querySelectorAll('#regionsFilter input[type="checkbox"]')
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
				processGeoJSON(geojsonData['regions'], 'regions', true)
			}
		})
		
		const equipmentCheckbox = document.getElementById('equipmentShow');
		equipmentCheckbox.checked = false;
		equipmentCheckbox.addEventListener('click', () => {
			// const checkbox = document.getElementById('equipmentShow');
			if (equipmentCheckbox.checked) {
				if (routesLayer == null) {
					loadGeoJSON("{{ url_for('equipment_data') }}", 'equipment');
				}
				else {
					loadGeoJSON("{{ url_for('equipment_data') }}", 'equipment');
					filterRoutesAndEquipment();
				};
			}
			else {
				if (equipmentLayer) map.removeLayer(equipmentLayer);
				equipmentLayer = null;
				console.log("5");
			}
		});

		const objectsCheckbox = document.getElementById('objectsShow');
		objectsCheckbox.checked = false;
		objectsCheckbox.addEventListener('click', () => {
			// const checkbox = document.getElementById('objectsShow');
			// data = fetchGeoJSON('/objects-geodata');
			loadGeoJSON("{{ url_for('objects_data') }}", 'objects');
			// if (objectsCheckbox.checked) {
			// 	const geoJsonLayer = L.geoJSON(data, {
			// 		style: function (feature) {
			// 			return {
			// 				color: 'black',
			// 				weight: 2
			// 			};
			// 		}
			// 	});
			// 	objectsLayer = geoJsonLayer;
			// 	// console.log("add", objectsLayer)
			// 	objectsLayer.addTo(map);
			// }
			// else {
			// 	if (objectsLayer) map.removeLayer(objectsLayer);
			// 	objectsLayer = null;
			// }

		});

		// Event listeners for buttons
		document.getElementById('load-routes').addEventListener('click', () => {
			loadGeoJSON("{{ url_for('routes_data') }}", 'routes');
		});

		document.getElementById('load-regions').addEventListener('click', () => {
			loadGeoJSON("{{ url_for('regions_data') }}", 'regions');
		});

		document.getElementById('showMoreButton').addEventListener('click', function () {
			const moreContent = document.getElementById('moreContent');
			if (moreContent.classList.contains('hidden')) {
				moreContent.classList.remove('hidden');
				this.textContent = 'Show Less';
			} else {
				moreContent.classList.add('hidden');
				this.textContent = 'Show More';
			}
		});
	</script>
</body>

</html>